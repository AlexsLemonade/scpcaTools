---
params:
  sample: Example
  unfiltered_sce: !r scpcaTools:::sim_sce()
  filtered_sce: NULL
  date: !r Sys.Date()

title: "`r glue::glue('ScPCA QC report for {params$sample}')`"
author: "Childhood Cancer Data Lab"
date: "`r params$date`"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
    number_sections: false
    code_download: true
---

```{r setup, message = FALSE, echo = FALSE}
# knitr options
knitr::opts_chunk$set(
  echo = FALSE
)

library(SingleCellExperiment)
library(dplyr)
library(ggplot2)

# Set default ggplot theme
theme_set(theme_bw() + 
          theme(plot.margin = margin(rep(20, 4))))
```

```{r sce_setup}
# save some typing later
sample_id <- params$sample
unfiltered_sce <- params$unfiltered_sce
filtered_sce <- params$filtered_sce

has_filtered <- !is.null(filtered_sce)

# if there is no filtered sce, use the unfiltered for both
if (!has_filtered){
  filtered_sce <- unfiltered_sce
}
# add cell stats if missing
if (is.null(unfiltered_sce$sum)){
  unfiltered_sce <- scuttle::addPerCellQCMetrics(unfiltered_sce)
}
if (is.null(filtered_sce$sum)){
  filtered_sce <- scuttle::addPerCellQCMetrics(filtered_sce)
  filtered_sce$subsets_mito_percent <- NA_real_
  skip_miQC <- TRUE
} else{
  skip_miQC <- FALSE
}
# add miQC model if missing
if (is.null(metadata(filtered_sce)$miQC_model) & !skip_miQC){
  metadata(filtered_sce)$miQC_model <- miQC::mixtureModel(filtered_sce)
}
```

# Processing Information for `r sample_id`

## Raw Sample Metrics

```{r }
# extract sce metadata containing processing information as table
unfiltered_meta <- metadata(unfiltered_sce) 

sample_information <- tibble::tibble(
  "Sample id" = sample_id,
  "Tech version" = format(unfiltered_meta$tech_version), # format to keep nulls
  "Number of reads sequenced" = format(unfiltered_meta$total_reads, big.mark = ',', scientific = FALSE),
  "Percent of reads mapped" = paste0(round((unfiltered_meta$mapped_reads/unfiltered_meta$total_reads) *100, 2), "%"),
  "Number of cells reported by alevin-fry" = format(unfiltered_meta$af_num_cells, big.mark = ',', scientific = FALSE)
) %>%
  mutate(across(.fns = ~ifelse(.x == "NULL", "N/A", .x))) %>% # reformat nulls
  t()

# make table with sample information
knitr::kable(sample_information, align = 'r') %>%
  kableExtra::kable_styling(bootstrap_options = "striped",
                            full_width = FALSE,
                            position = "left") %>%
  kableExtra::column_spec(2, monospace = TRUE)
```

## Pre-Processing Information

```{r }
processing_info <- tibble::tibble(
  "Salmon version"       = format(unfiltered_meta$salmon_version),
  "Alevin-fry version"   = format(unfiltered_meta$alevinfry_version),
  "Transcriptome index"  = format(unfiltered_meta$reference_index),
  "Filtering method"     = format(unfiltered_meta$af_permit_type),
  "Resolution"           = format(unfiltered_meta$af_resolution), 
  "Transcripts included" = dplyr::case_when(
      format(unfiltered_meta$transcript_type) == "spliced" ~ "Spliced only",
      format(unfiltered_meta$transcript_type) == "unspliced" ~ "Spliced and unspliced",
      TRUE ~ format(unfiltered_meta$transcript_type))
  ) %>%
  mutate(across(.fns = ~ifelse(.x == "NULL", "N/A", .x))) %>%
  t()


# make table with processing information
knitr::kable(processing_info, align = 'r') %>%
  kableExtra::kable_styling(bootstrap_options = "striped",
                            full_width = FALSE,
                            position = "left") %>%
  kableExtra::column_spec(2, monospace = TRUE)
```

# `r sample_id` Experiment Summary 

This sample has `r ncol(unfiltered_sce)` cells, assayed for `r nrow(unfiltered_sce)` genes.

```{r, results = 'asis'}
if(has_filtered){
  cat("After filtering, there are", ncol(filtered_sce), "cells.")
}
```

## Cell Statistics 

```{r}
basic_statistics <- tibble::tibble(
  "Number of cells post filtering"     = format(ncol(filtered_sce), big.mark = ","),
  "Percent of reads in cells"          = paste0(round((sum(filtered_sce$sum)/sum(unfiltered_sce$sum))*100,2),"%"),
  "Median UMI count per cell"          = format(median(filtered_sce$sum), big.mark = ","),
  "Median genes detected per cell"     = format(median(filtered_sce$detected), big.mark = ","),
  "Median percent reads mitochondrial" = paste0(round(median(filtered_sce$subsets_mito_percent), 2), "%")
  ) %>%
  mutate(across(.fns = ~ifelse(.x == "NULL", "N/A", .x))) %>%
  t()


# make table with basic statistics
knitr::kable(basic_statistics, align = 'r') %>%
  kableExtra::kable_styling(bootstrap_options = "striped",
                            full_width = FALSE,
                            position = "left") %>%
  kableExtra::column_spec(2, monospace = TRUE)

```

## Knee Plot

```{r, fig.alt="Knee plot of filtered and unfiltered droplets"}
unfiltered_celldata <- data.frame(colData(unfiltered_sce)) %>%
  mutate(
    rank = rank(- unfiltered_sce$sum, ties.method = "first"), # using full spec for clarity 
    filter_status = factor(ifelse(colnames(unfiltered_sce) %in% colnames(filtered_sce),
                                  "Passed", "Excluded"),
                           levels = c("Passed", "Excluded"))
  ) %>%
  filter(sum > 0) %>% # remove zeros for plotting
  arrange(desc(rank))

ggplot(unfiltered_celldata, aes(x = rank, y = sum, color = filter_status))+
  geom_point(aes(size = filter_status), alpha = 0.2) +
  scale_x_log10(labels = scales::label_number()) +
  scale_y_log10(labels = scales::label_number()) + 
  scale_color_manual(values = c("darkgreen", "grey80")) + 
  scale_size_manual(values = c(2, 1)) +
  labs(
    x = "Rank", 
    y = "Total UMI count",
    color = "Filter status",
    size  = "Filter status"
  ) + 
  guides(color = guide_legend(override.aes = list(alpha = 1))) + 
  theme(legend.position = c(0, 0),
        legend.justification = c(0,0),
        legend.background = element_rect(color = "grey20", size = 0.25),
        legend.box.margin = margin(rep(5, 4)))
```

```{r, fig.alt="Smoothed knee plot of filtered and unfiltered droplets"}
grouped_celldata <- unfiltered_celldata %>%
  select(sum, rank, filter_status) %>%
  mutate(rank_group = floor(rank / 100) )%>%
  group_by(rank_group) %>%
  summarize(
    med_sum = median(sum),
    med_rank = median(rank),
    pct_passed = sum(filter_status == "Passed") / n() * 100
  )

top_celldata <- unfiltered_celldata %>%
  select(sum, rank, filter_status) %>%
  filter(rank <= 50) %>%
  mutate(filter_status = ifelse(filter_status == "Passed", 100, 0))

ggplot(grouped_celldata, aes(x = med_rank, y = med_sum, color = pct_passed)) + 
  geom_point(mapping = aes(x = rank, y = sum, color = filter_status),
             data = top_celldata,
             alpha = 0.5) + 
  geom_line(size = 2, lineend = "round", linejoin= "round") +
  scale_x_log10(labels = scales::label_number()) +
  scale_y_log10(labels = scales::label_number(accuracy = 1)) + 
  scale_color_gradient2(low = "grey70", 
                        mid = "forestgreen", 
                        high = "darkgreen", 
                        midpoint = 50) +
  labs(
    x = "Rank", 
    y = "Total UMI count",
    color = "% passing\ncell filter"
  ) + 
  theme(legend.position = c(0, 0),
        legend.justification = c(0,0),
        legend.background = element_rect(color = "grey20", size = 0.25),
        legend.box.margin = margin(rep(5, 4)))
```

The total UMI count of each droplet (barcode) plotted against the rank of that droplet allows visualization of the distribution of sequencing depth across droplets. 
The droplets that are expected to contain cells were identified with [`DropletUtils::emptyDrops()`](https://bioconductor.org/packages/release/bioc/html/DropletUtils.html) , which uses both the total UMI counts and expressed gene content ([Lun  _et al._ 2019](https://doi.org/10.1186/s13059-019-1662-y)).
As the boundary between droplets passing and failing this filter does not correspond only to the axes of this plot, some regions contain droplets in both categories, so we here color the plot by the percentage passing the filter.

## Cell Read Metrics 

```{r, fig.alt="Total UMI x genes expressed"}
filtered_celldata <- data.frame(colData(filtered_sce)) 

ggplot(filtered_celldata, 
       aes (x = sum,
            y = detected, 
            color = subsets_mito_percent)) +
  geom_point(alpha = 0.3) +
  scale_color_viridis_c(limits = c(0, 100)) + 
  labs(x = "Total UMI count",
       y = "Number of genes detected",
       color = "Percent reads\nmitochondrial") + 
  theme(legend.position = c(0, 1),
        legend.justification = c(0,1),
        legend.background = element_rect(color = "grey20", size = 0.25),
        legend.box.margin = margin(rep(5, 4)))
```

The above plot of cell metrics includes only droplets which have passed the `emptyDrops()` filter.
The plot will usually display a strong (but curved) relationship between the total UMI count and the number of genes detected.
Cells with low counts and high mitochondrial percentages may require further filtering.

## miQC Model Diagnostics

```{r, fig.alt="miQC model diagnostics plot", results='asis', warning=FALSE}
if(skip_miQC){
  cat("miQC model not created, skipping miQC plot. Usually this is because mitochondrial gene data was not available.")
}else{
  # remove prob_compromised if it exists, as this will cause errors with plotModel
  filtered_sce$prob_compromised <- NULL
  miQC::plotModel(filtered_sce, model = metadata(filtered_sce)$miQC_model) + 
    coord_cartesian(ylim = c(0,100)) +
    labs(x = "Number of genes detected",
         y = "Percent reads mitochondrial") +
    theme(legend.position = c(1, 1),
          legend.justification = c(1,1),
          legend.background = element_rect(color = "grey20", size = 0.25),
          legend.box.margin = margin(rep(5, 4)))
}
```

We calculate the probability that a cell is compromised due to degradation or rupture using [`miQC`](https://bioconductor.org/packages/release/bioc/html/miQC.html) ([Hippen _et al._ 2021](https://doi.org/10.1371/journal.pcbi.1009290)).
This relies on fitting a mixture model using the number of genes expressed by a cell and the percentage of mitochondrial reads.
The expected plot will show a characteristic triangular shape and two model fit lines.
Cells with low numbers of genes expressed may have both low and high mitochondrial percentage, but cells with many genes tend to have a low mitochondrial percentage.
If the model has failed to fit properly, the pattern of cells may differ, and there may only be one model fit line. 
In such situations, the calculated probability of compromise may not be valid (see [miQC vignette](https://bioconductor.org/packages/3.13/bioc/vignettes/miQC/inst/doc/miQC.html#when-not-to-use-miqc) for more details).

# Session Info
<details>
<summary>R session information</summary>
```{r session_info}
sessioninfo::session_info()
```
</details>

